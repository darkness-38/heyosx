#!/usr/bin/env bash
# =============================================================================
# hey-install — heyOS CLI Installer (OPTIMIZED)
#
# Optimized for speed, disk performance, and intelligent network handling.
# =============================================================================

set -euo pipefail

# ---- Color codes ----
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PINK='\033[1;35m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# ---- Configuration ----
MOUNT_POINT="/mnt"
LOG_FILE="/var/log/hey-install.log"
SELECTED_TIMEZONE="UTC"
SELECTED_LOCALE="en_US.UTF-8"
SELECTED_KEYMAP="us"
OFFLINE_REPO="/opt/heyos-packages"

# =============================================================================
# Utility Functions
# =============================================================================

log_info()  { echo -e "${BLUE}[INFO]${NC}  $*" | tee -a "$LOG_FILE"; }
log_ok()    { echo -e "${GREEN}[OK]${NC}    $*" | tee -a "$LOG_FILE"; }
log_warn()  { echo -e "${YELLOW}[WARN]${NC}  $*" | tee -a "$LOG_FILE"; }
log_err()   { echo -e "${RED}[ERROR]${NC} $*" | tee -a "$LOG_FILE"; }
log_step()  { echo -e "\n${PINK}${BOLD}==> $*${NC}" | tee -a "$LOG_FILE"; }
log_task()  { echo -e "${CYAN}[TASK]${NC}  $*" | tee -a "$LOG_FILE"; }

# Display a list of items in a compact grid format
display_grid() {
    local items=("$@")
    local term_width=$(tput cols 2>/dev/null || echo 80)
    local max_len=0
    
    for item in "${items[@]}"; do
        [[ ${#item} -gt $max_len ]] && max_len=${#item}
    done
    
    local col_width=$((max_len + 2))
    local cols=$((term_width / col_width))
    [[ $cols -lt 1 ]] && cols=1
    
    # Use printf to create the grid
    local count=0
    for item in "${items[@]}"; do
        printf "%-${col_width}s" "$item"
        ((count+=1))
        if [[ $((count % cols)) -eq 0 ]]; then
            echo ""
        fi
    done
    echo ""
}

# Helper: find best match for a string in a list
fuzzy_match() {
    local input="$1"
    shift
    local items=("$@")

    for i in "${items[@]}"; do
        [[ "$i" == "$input" ]] && { echo "$i"; return 0; }
    done
    for i in "${items[@]}"; do
        [[ "${i,,}" == "${input,,}" ]] && { echo "$i"; return 0; }
    done
    for i in "${items[@]}"; do
        [[ "${i,,}" == "${input,,}"* ]] && { echo "$i"; return 0; }
    done
    for i in "${items[@]}"; do
        [[ "${i,,}" == *"${input,,}"* ]] && { echo "$i"; return 0; }
    done
    return 1
}

confirm() {
    local prompt="${1:-Continue?}"
    echo -en "${YELLOW}${prompt} [y/N]: ${NC}"
    read -r response
    [[ "$response" =~ ^[Yy]$ ]]
}

show_banner() {
    echo -e "${PINK}"
    cat << 'EOF'

    ██╗  ██╗███████╗██╗   ██╗ ██████╗ ███████╗
    ██║  ██║██╔════╝╚██╗ ██╔╝██╔═══██╗██╔════╝
    ███████║█████╗   ╚████╔╝ ██║   ██║███████╗
    ██╔══██║██╔══╝    ╚██╔╝  ██║   ██║╚════██║
    ██║  ██║███████╗   ██║   ╚██████╔╝███████║
    ╚═╝  ╚═╝╚══════╝   ╚═╝    ╚═════╝ ╚══════╝

            ═══ System Installer ═══
EOF
    echo -e "${NC}"
}

# =============================================================================
# Pre-flight Checks
# =============================================================================

preflight_checks() {
    log_step "Running pre-flight checks"
    trap cleanup EXIT

    log_info "Verifying root privileges..."
    if [[ $EUID -ne 0 ]]; then
        log_err "This installer must be run as root (use sudo)."
        exit 1
    fi

    log_info "Checking boot mode (UEFI/BIOS)..."
    if [[ ! -d /sys/firmware/efi ]]; then
        log_warn "EFI firmware not detected. This installer requires UEFI boot."
        if ! confirm "Continue anyway (BIOS mode)?"; then exit 1; fi
        BOOT_MODE="bios"
        log_info "Proceeding in BIOS legacy mode."
    else
        BOOT_MODE="uefi"
        log_ok "UEFI boot mode detected"
    fi

    log_info "Checking network connectivity..."
    if ! ping -c 1 -W 2 archlinux.org &>/dev/null; then
        if [[ ! -d "$OFFLINE_REPO" ]]; then
            log_err "No network and no offline cache found. Installation cannot continue."
            exit 1
        fi
        log_warn "No network detected — falling back to OFFLINE mode."
        IS_OFFLINE=true
    else
        log_ok "Network connectivity confirmed."
        IS_OFFLINE=false
    fi

    log_info "Synchronizing system clock..."
    timedatectl set-ntp true 2>/dev/null || true
    log_ok "Clock synchronized."
}

# =============================================================================
# Disk & Filesystem Selection
# =============================================================================

select_disk() {
    log_step "Disk Selection"
    echo -e "\n${BOLD}Available disks:${NC}\n"
    lsblk -dpno NAME,SIZE,MODEL | grep -v "^/dev/loop\|^/dev/sr\|^/dev/ram" || true
    echo ""

    while true; do
        echo -en "${BOLD}Enter target disk (e.g., /dev/sda): ${NC}"
        read -r TARGET_DISK
        [[ -b "$TARGET_DISK" ]] && break
        log_err "'$TARGET_DISK' is not a valid block device."
    done

    echo -e "\n${RED}${BOLD}WARNING: ALL DATA on $TARGET_DISK will be DESTROYED!${NC}"
    if confirm "Are you absolutely sure?"; then
        log_ok "Target disk: $TARGET_DISK"
    else
        log_info "Installation cancelled by user."
        exit 1
    fi
}

select_filesystem() {
    log_step "Filesystem Selection"
    echo -e "\n${BOLD}Choose filesystem for root partition:${NC}"
    echo "  1) ext4  (stable, fast)"
    echo "  2) btrfs (advanced, snapshots, compression)"
    echo ""

    while true; do
        echo -en "${BOLD}Choice [1/2]: ${NC}"
        read -r fs_choice
        case "$fs_choice" in
            1) ROOT_FS="ext4"; break ;;
            2) ROOT_FS="btrfs"; break ;;
            *) log_err "Invalid choice." ;;
        esac
    done
    log_ok "Selected filesystem: $ROOT_FS"
}

# =============================================================================
# Localization Setup
# =============================================================================

select_localization() {
    log_step "Localization Setup"

    # Timezone
    mapfile -t tz_list < <(find /usr/share/zoneinfo -maxdepth 2 -type f -not -name "*.tab" -not -name "posix*" -not -name "right*" | sed 's|/usr/share/zoneinfo/||' | sort)
    while true; do
        echo -en "\n${BOLD}Timezone [${SELECTED_TIMEZONE}]: ${NC}"
        read -r tz_input
        [[ -z "$tz_input" ]] && break
        [[ "$tz_input" == "list" ]] && { display_grid "${tz_list[@]}"; continue; }
        
        if [[ -f "/usr/share/zoneinfo/$tz_input" ]]; then
            SELECTED_TIMEZONE="$tz_input"
            break
        else
            best_match=$(fuzzy_match "$tz_input" "${tz_list[@]}") || true
            if [[ -n "$best_match" ]]; then
                SELECTED_TIMEZONE="$best_match"
                log_info "Autocorrected timezone to '$best_match'"
                break
            fi
            log_err "Invalid timezone."
        fi
    done

    # Keymap
    mapfile -t key_list < <(localectl list-keymaps 2>/dev/null || find /usr/share/kbd/keymaps -type f -name "*.map.gz" -printf "%f\n" | sed 's/.map.gz//' | sort)
    while true; do
        echo -en "\n${BOLD}Layout [${SELECTED_KEYMAP}]: ${NC}"
        read -r key_input
        [[ -z "$key_input" ]] && break
        [[ "$key_input" == "list" ]] && { display_grid "${key_list[@]}"; continue; }

        best_match=$(fuzzy_match "$key_input" "${key_list[@]}") || true
        if [[ -n "$best_match" ]]; then
            SELECTED_KEYMAP="$best_match"
            log_info "Autocorrected layout to '$best_match'"
            break
        fi
    done

    # Locale
    mapfile -t loc_list < <(grep -E "^[a-z]{2}_[A-Z]{2}" /usr/share/i18n/SUPPORTED 2>/dev/null | awk '{print $1}')
    while true; do
        echo -en "\n${BOLD}Locale [${SELECTED_LOCALE}]: ${NC}"
        read -r loc_input
        [[ -z "$loc_input" ]] && break
        [[ "$loc_input" == "list" ]] && { display_grid "${loc_list[@]}"; continue; }

        best_match=$(fuzzy_match "$loc_input" "${loc_list[@]}") || true
        if [[ -n "$best_match" ]]; then
            SELECTED_LOCALE="$best_match"
            log_info "Autocorrected locale to '$best_match'"
            break
        fi
    done
    log_ok "Localization settings saved."
}

# =============================================================================
# Partitioning & Formatting
# =============================================================================

partition_disk() {
    log_step "Partitioning $TARGET_DISK"
    
    log_info "Wiping existing partition table and signatures..."
    wipefs -af "$TARGET_DISK" &>/dev/null
    sgdisk --zap-all "$TARGET_DISK" &>/dev/null

    if [[ "$BOOT_MODE" == "uefi" ]]; then
        log_info "Creating GPT partitions (512M EFI, remainder Root)..."
        sgdisk -n 1:0:+512M -t 1:EF00 -c 1:"EFI" "$TARGET_DISK" &>/dev/null
        sgdisk -n 2:0:0     -t 2:8300 -c 2:"Root" "$TARGET_DISK" &>/dev/null
        
        log_info "Probing for new partitions..."
        partprobe "$TARGET_DISK" && udevadm settle
        
        EFI_PART=$(lsblk -rnpo NAME,PARTN "$TARGET_DISK" | awk '$2=="1" {print $1}')
        ROOT_PART=$(lsblk -rnpo NAME,PARTN "$TARGET_DISK" | awk '$2=="2" {print $1}')
    else
        log_info "Creating MBR partitions (BIOS legacy)..."
        echo -e "o\nn\np\n1\n\n\nw" | fdisk "$TARGET_DISK" &>/dev/null
        
        log_info "Probing for new partitions..."
        partprobe "$TARGET_DISK" && udevadm settle
        
        ROOT_PART=$(lsblk -rnpo NAME,PARTN "$TARGET_DISK" | awk '$2=="1" {print $1}')
        EFI_PART=""
    fi
    log_ok "Partitioning complete. Root: $ROOT_PART, EFI: ${EFI_PART:-None}"
}

format_partitions() {
    log_step "Formatting partitions"
    if [[ -n "${EFI_PART:-}" ]]; then
        log_info "Formatting EFI partition $EFI_PART as FAT32..."
        mkfs.fat -F32 "$EFI_PART" &>/dev/null
        log_ok "EFI formatted."
    fi
    
    log_info "Formatting root partition $ROOT_PART as $ROOT_FS..."
    case "$ROOT_FS" in
        ext4)  mkfs.ext4 -F -L "heyOS" "$ROOT_PART" &>/dev/null ;;
        btrfs) mkfs.btrfs -f -L "heyOS" "$ROOT_PART" &>/dev/null ;;
    esac
    log_ok "Root formatted as $ROOT_FS."
}

# =============================================================================
# Mounting (PERFORMANCE OPTIMIZED)
# =============================================================================

mount_filesystems() {
    log_step "Mounting filesystems"
    
    # Common mount options for speed
    local EXT4_OPTS="noatime,data=ordered"
    local BTRFS_OPTS="noatime,compress=zstd,space_cache=v2,commit=120"

    if [[ "$ROOT_FS" == "btrfs" ]]; then
        log_info "Creating Btrfs subvolumes (@ and @home)..."
        mount "$ROOT_PART" "$MOUNT_POINT"
        btrfs subvolume create "$MOUNT_POINT/@" &>/dev/null
        btrfs subvolume create "$MOUNT_POINT/@home" &>/dev/null
        umount "$MOUNT_POINT"

        log_info "Mounting subvolumes with optimized options (compress=zstd)..."
        mount -o "$BTRFS_OPTS,subvol=@" "$ROOT_PART" "$MOUNT_POINT"
        mkdir -p "$MOUNT_POINT/home"
        mount -o "$BTRFS_OPTS,subvol=@home" "$ROOT_PART" "$MOUNT_POINT/home"
    else
        log_info "Mounting Ext4 root partition..."
        mount -o "$EXT4_OPTS" "$ROOT_PART" "$MOUNT_POINT"
    fi

    if [[ -n "${EFI_PART:-}" ]]; then
        log_info "Mounting EFI partition to /boot/efi..."
        mkdir -p "$MOUNT_POINT/boot/efi"
        mount "$EFI_PART" "$MOUNT_POINT/boot/efi"
    fi
    log_ok "All filesystems mounted at $MOUNT_POINT"
}

# =============================================================================
# Installation (SPEED OPTIMIZED)
# =============================================================================

install_base() {
    log_step "Installing base system"

    log_info "Enabling parallel downloads in pacman.conf..."
    sed -i 's/^#ParallelDownloads/ParallelDownloads/' /etc/pacman.conf

    # SPEED: Skip slow keyring init if possible
    if [[ -d /etc/pacman.d/gnupg ]]; then
        log_info "Reusing host keyring for speed..."
    else
        log_info "Initializing pacman keyring..."
        # Ensure entropy for pacman-key
        log_info "Starting haveged for entropy generation..."
        pacman -Sy --noconfirm haveged &>/dev/null || true
        systemctl start haveged &>/dev/null || true
        pacman-key --init &>/dev/null
        pacman-key --populate archlinux &>/dev/null
        log_ok "Keyring initialized."
    fi

    # SPEED: Mirror selection
    if ! $IS_OFFLINE; then
        log_info "Updating mirrors (selecting fastest 5 HTTPS mirrors)..."
        reflector --latest 5 --protocol https --sort rate --save /etc/pacman.d/mirrorlist &>/dev/null || true
        log_ok "Mirrorlist optimized."
    fi

    local PACKAGES=(
        base linux linux-firmware archlinux-keyring sudo systemd networkmanager
        pipewire pipewire-pulse pipewire-alsa wireplumber open-vm-tools mesa
        nano vim alacritty firefox thunar wayland wayland-protocols libxkbcommon
        libinput seatd xorg-xwayland cage greetd ttf-dejavu ttf-liberation noto-fonts
        grub efibootmgr dosfstools os-prober amd-ucode intel-ucode dbus gvfs tumbler
        bash-completion which less man-db man-pages memtest86+ memtest86+-efi
        haveged
    )
    [[ "$ROOT_FS" == "btrfs" ]] && PACKAGES+=(btrfs-progs)

    # SPEED: If offline repo exists, use it as a local source (Instant)
    if [[ -d "$OFFLINE_REPO" ]]; then
        log_info "Deploying packages from high-speed offline cache ($OFFLINE_REPO)..."
        pacstrap -K "$MOUNT_POINT" "${PACKAGES[@]}" --cachedir "$OFFLINE_REPO" 2>&1 | tee -a "$LOG_FILE"
    else
        log_info "Downloading and installing base packages..."
        pacstrap -K "$MOUNT_POINT" "${PACKAGES[@]}" 2>&1 | tee -a "$LOG_FILE"
    fi
    log_ok "Base system installed successfully."
}

configure_system() {
    log_step "Configuring installed system"
    
    log_info "Generating fstab..."
    # SPEED: Fast fstab generation
    # Remount with safer options before generating fstab so they don't leak into the config
    if [[ "$ROOT_FS" == "btrfs" ]]; then
        mount -o remount,noatime,compress=zstd,subvol=@ "$ROOT_PART" "$MOUNT_POINT"
    fi
    genfstab -U "$MOUNT_POINT" >> "$MOUNT_POINT/etc/fstab"

    log_info "Deploying custom heyDM and hey-greeter binaries..."
    cp /usr/bin/heydm "$MOUNT_POINT/usr/bin/heydm"
    cp /usr/bin/hey-greeter "$MOUNT_POINT/usr/bin/hey-greeter"
    chmod 755 "$MOUNT_POINT/usr/bin/heydm" "$MOUNT_POINT/usr/bin/hey-greeter"

    log_info "Setting up Wayland session and Greetd configuration..."
    mkdir -p "$MOUNT_POINT/usr/share/wayland-sessions"
    cat << 'EOF' > "$MOUNT_POINT/usr/share/wayland-sessions/heydm.desktop"
[Desktop Entry]
Name=heyDM
Exec=cage -d -s -- /usr/bin/heydm
Type=Application
EOF

    mkdir -p "$MOUNT_POINT/etc/greetd"
    cat << 'EOF' > "$MOUNT_POINT/etc/greetd/config.toml"
[terminal]
vt = 1
[default_session]
command = "cage -s -- /usr/bin/hey-greeter"
user = "greeter"
EOF

    log_info "Entering chroot for localized configuration..."
    # CHROOT setup
    cat << CHROOT_SCRIPT > "$MOUNT_POINT/root/hey-setup.sh"
#!/bin/bash
set -e
echo "[CHROOT] Setting timezone to ${SELECTED_TIMEZONE}..."
ln -sf /usr/share/zoneinfo/${SELECTED_TIMEZONE} /etc/localtime
hwclock --systohc

echo "[CHROOT] Generating locale ${SELECTED_LOCALE}..."
if grep -q "^#${SELECTED_LOCALE}" /etc/locale.gen; then
    sed -i "s/^#${SELECTED_LOCALE}/${SELECTED_LOCALE}/" /etc/locale.gen
else
    echo "${SELECTED_LOCALE} UTF-8" >> /etc/locale.gen
fi
locale-gen &>/dev/null
echo "LANG=${SELECTED_LOCALE}" > /etc/locale.conf

echo "[CHROOT] Setting hostname and keymap..."
echo "KEYMAP=${SELECTED_KEYMAP}" > /etc/vconsole.conf
echo "heyOS" > /etc/hostname

echo "[CHROOT] Enabling system services..."
systemctl enable NetworkManager.service seatd.service greetd.service haveged.service &>/dev/null
systemctl set-default graphical.target &>/dev/null

echo "[CHROOT] Configuring user groups and permissions..."
usermod -aG seat greeter || true
echo "%wheel ALL=(ALL:ALL) ALL" > /etc/sudoers.d/00-heyos
chmod 440 /etc/sudoers.d/00-heyos

echo "[CHROOT] Rebuilding initramfs..."
mkinitcpio -P &>/dev/null
CHROOT_SCRIPT

    chmod +x "$MOUNT_POINT/root/hey-setup.sh"
    arch-chroot "$MOUNT_POINT" /root/hey-setup.sh 2>&1 | tee -a "$LOG_FILE"
    rm -f "$MOUNT_POINT/root/hey-setup.sh"
    log_ok "System configuration complete."
}

install_bootloader() {
    log_step "Installing bootloader"
    if [[ "$BOOT_MODE" == "uefi" ]]; then
        log_info "Installing GRUB for UEFI..."
        arch-chroot "$MOUNT_POINT" grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=heyOS --recheck &>/dev/null
    else
        log_info "Installing GRUB for BIOS (Legacy)..."
        arch-chroot "$MOUNT_POINT" grub-install --target=i386-pc "$TARGET_DISK" &>/dev/null
    fi
    
    log_info "Generating GRUB config file..."
    arch-chroot "$MOUNT_POINT" grub-mkconfig -o /boot/grub/grub.cfg &>/dev/null
    log_ok "Bootloader ready."
}

setup_user() {
    log_step "User Account Setup"
    echo -en "Set root password:\n"
    while ! arch-chroot "$MOUNT_POINT" passwd; do :; done

    echo ""
    while true; do
        echo -en "Enter username: "
        read -r NEW_USER
        [[ "$NEW_USER" =~ ^[a-z_][a-z0-9_-]*$ ]] && break
        log_err "Invalid username. Use lowercase letters and numbers only."
    done

    log_info "Creating user '$NEW_USER' with render and seat access..."
    arch-chroot "$MOUNT_POINT" useradd -m -G wheel,video,render,audio,input,seat -s /bin/bash "$NEW_USER"
    
    echo -en "Set password for '$NEW_USER':\n"
    while ! arch-chroot "$MOUNT_POINT" passwd "$NEW_USER"; do :; done
    log_ok "User '$NEW_USER' created successfully."
}

cleanup() {
    log_step "Finalizing..."
    log_info "Unmounting all filesystems..."
    mountpoint -q "$MOUNT_POINT" && umount -R "$MOUNT_POINT" &>/dev/null || true
    trap - EXIT
    log_ok "Cleanup complete."
}

# =============================================================================
# Main
# =============================================================================

main() {
    show_banner
    preflight_checks
    select_disk
    select_filesystem
    select_localization
    
    # EXECUTION START
    partition_disk
    format_partitions
    mount_filesystems
    install_base
    configure_system
    install_bootloader
    setup_user
    cleanup
    
    echo -e "\n${GREEN}${BOLD}heyOS installation complete! Reboot to enjoy.${NC}"
}

main "$@"
