#!/usr/bin/env bash
# =============================================================================
# hey-install — heyOS CLI Installer
#
# A comprehensive, interactive CLI installer for heyOS.
# Automates: disk partitioning, formatting, pacstrap, bootloader setup,
# user creation, and heyDM desktop environment deployment.
#
# Usage: sudo hey-install
# =============================================================================

set -euo pipefail

# ---- Color codes ----
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# ---- Configuration ----
MOUNT_POINT="/mnt"
LOG_FILE="/var/log/hey-install.log"

# =============================================================================
# Utility Functions
# =============================================================================

log_info()  { echo -e "${BLUE}[INFO]${NC}  $*" | tee -a "$LOG_FILE"; }
log_ok()    { echo -e "${GREEN}[OK]${NC}    $*" | tee -a "$LOG_FILE"; }
log_warn()  { echo -e "${YELLOW}[WARN]${NC}  $*" | tee -a "$LOG_FILE"; }
log_err()   { echo -e "${RED}[ERROR]${NC} $*" | tee -a "$LOG_FILE"; }
log_step()  { echo -e "\n${CYAN}${BOLD}==> $*${NC}" | tee -a "$LOG_FILE"; }

# Prompt the user with a question, return 0 for yes
confirm() {
    local prompt="${1:-Continue?}"
    echo -en "${YELLOW}${prompt} [y/N]: ${NC}"
    read -r response
    [[ "$response" =~ ^[Yy]$ ]]
}

# Display the heyOS banner
show_banner() {
    echo -e "${CYAN}"
    cat << 'EOF'

    ██╗  ██╗███████╗██╗   ██╗ ██████╗ ███████╗
    ██║  ██║██╔════╝╚██╗ ██╔╝██╔═══██╗██╔════╝
    ███████║█████╗   ╚████╔╝ ██║   ██║███████╗
    ██╔══██║██╔══╝    ╚██╔╝  ██║   ██║╚════██║
    ██║  ██║███████╗   ██║   ╚██████╔╝███████║
    ╚═╝  ╚═╝╚══════╝   ╚═╝    ╚═════╝ ╚══════╝

          ═══ System Installer v0.1 ═══
EOF
    echo -e "${NC}"
}

# =============================================================================
# Pre-flight Checks
# =============================================================================

preflight_checks() {
    log_step "Running pre-flight checks"

    # Trap EXIT to ensure we always unmount if the script fails or is Ctrl+C'd
    trap cleanup EXIT

    # Must be root
    if [[ $EUID -ne 0 ]]; then
        log_err "This installer must be run as root (use sudo)."
        exit 1
    fi

    # Verify we're booted in UEFI mode
    if [[ ! -d /sys/firmware/efi ]]; then
        log_warn "EFI firmware not detected. This installer requires UEFI boot."
        log_warn "If running in a VM, ensure EFI boot is enabled."
        if ! confirm "Continue anyway (BIOS mode)?"; then
            exit 1
        fi
        BOOT_MODE="bios"
    else
        BOOT_MODE="uefi"
        log_ok "UEFI boot mode detected"
    fi

    # Check network connectivity
    if ping -c 1 -W 2 archlinux.org &>/dev/null; then
        log_ok "Network connectivity confirmed"
    else
        log_err "No network connectivity. Please configure networking first."
        log_info "Try: nmcli device wifi connect <SSID> password <password>"
        exit 1
    fi

    # Sync time
    timedatectl set-ntp true 2>/dev/null || true
    log_ok "System clock synchronized"
}

# =============================================================================
# Disk Selection
# =============================================================================

select_disk() {
    log_step "Disk Selection"

    echo -e "\n${BOLD}Available disks:${NC}\n"
    lsblk -dpno NAME,SIZE,MODEL | grep -v "^/dev/loop\|^/dev/sr\|^/dev/ram"
    echo ""

    while true; do
        echo -en "${BOLD}Enter target disk (e.g., /dev/sda or /dev/vda): ${NC}"
        read -r TARGET_DISK

        if [[ ! -b "$TARGET_DISK" ]]; then
            log_err "'$TARGET_DISK' is not a valid block device."
            continue
        fi

        echo -e "\n${RED}${BOLD}WARNING: ALL DATA on $TARGET_DISK will be DESTROYED!${NC}"
        echo -e "Disk: $(lsblk -dpno NAME,SIZE,MODEL "$TARGET_DISK")\n"

        if confirm "Are you absolutely sure?"; then
            break
        fi
    done

    log_ok "Target disk: $TARGET_DISK"
}

# =============================================================================
# Filesystem Selection
# =============================================================================

select_filesystem() {
    log_step "Filesystem Selection"

    echo -e "\n${BOLD}Choose filesystem for root partition:${NC}"
    echo "  1) ext4  (stable, widely supported)"
    echo "  2) btrfs (copy-on-write, snapshots)"
    echo ""

    while true; do
        echo -en "${BOLD}Choice [1/2]: ${NC}"
        read -r fs_choice
        case "$fs_choice" in
            1) ROOT_FS="ext4"; break ;;
            2) ROOT_FS="btrfs"; break ;;
            *) log_err "Invalid choice. Enter 1 or 2." ;;
        esac
    done

    log_ok "Filesystem: $ROOT_FS"
}

# =============================================================================
# Disk Partitioning
# =============================================================================

partition_disk() {
    log_step "Partitioning $TARGET_DISK"

    # Wipe existing partition table
    wipefs -af "$TARGET_DISK" >> "$LOG_FILE" 2>&1
    sgdisk --zap-all "$TARGET_DISK" >> "$LOG_FILE" 2>&1

    if [[ "$BOOT_MODE" == "uefi" ]]; then
        # GPT partition table for UEFI
        log_info "Creating GPT partition table (UEFI)..."
        sgdisk -n 1:0:+512M -t 1:EF00 -c 1:"EFI System" "$TARGET_DISK" >> "$LOG_FILE" 2>&1
        sgdisk -n 2:0:0     -t 2:8300 -c 2:"heyOS Root"  "$TARGET_DISK" >> "$LOG_FILE" 2>&1

        # Use lsblk to safely find the new partitions regardless of naming scheme (e.g. sda1 vs nvmeON1p1)
        partprobe "$TARGET_DISK" 2>/dev/null || true
        sleep 2
        EFI_PART=$(lsblk -rnpo NAME "$TARGET_DISK" | sed '1d' | head -n 1)
        ROOT_PART=$(lsblk -rnpo NAME "$TARGET_DISK" | sed '1,2d' | head -n 1)
        
        if [[ -z "$EFI_PART" || -z "$ROOT_PART" ]]; then
             log_err "Failed to detect newly created UEFI partitions."
             exit 1
        fi
    else
        # MBR for BIOS
        log_info "Creating MBR partition table (BIOS)..."
        echo -e "o\nn\np\n1\n\n\nw" | fdisk "$TARGET_DISK" >> "$LOG_FILE" 2>&1

        partprobe "$TARGET_DISK" 2>/dev/null || true
        sleep 2
        ROOT_PART=$(lsblk -rnpo NAME "$TARGET_DISK" | sed '1d' | head -n 1)
        EFI_PART=""
        
        if [[ -z "$ROOT_PART" ]]; then
             log_err "Failed to detect newly created BIOS partition."
             exit 1
        fi
    fi

    log_ok "Partitioning complete"
    log_info "  EFI:  ${EFI_PART:-N/A}"
    log_info "  Root: ${ROOT_PART}"
}

# =============================================================================
# Filesystem Formatting
# =============================================================================

format_partitions() {
    log_step "Formatting partitions"

    # Format EFI partition (if UEFI)
    if [[ -n "${EFI_PART:-}" ]]; then
        log_info "Formatting EFI partition as FAT32..."
        mkfs.fat -F32 "$EFI_PART" >> "$LOG_FILE" 2>&1
        log_ok "EFI partition formatted: $EFI_PART"
    fi

    # Format root partition
    log_info "Formatting root partition as $ROOT_FS..."
    case "$ROOT_FS" in
        ext4)
            mkfs.ext4 -F -L "heyOS" "$ROOT_PART" >> "$LOG_FILE" 2>&1
            ;;
        btrfs)
            mkfs.btrfs -f -L "heyOS" "$ROOT_PART" >> "$LOG_FILE" 2>&1
            ;;
    esac
    log_ok "Root partition formatted: $ROOT_PART ($ROOT_FS)"
}

# =============================================================================
# Mount Filesystems
# =============================================================================

mount_filesystems() {
    log_step "Mounting filesystems"

    # Mount root
    if [[ "$ROOT_FS" == "btrfs" ]]; then
        # Create btrfs subvolumes
        mount "$ROOT_PART" "$MOUNT_POINT"
        btrfs subvolume create "$MOUNT_POINT/@" >> "$LOG_FILE" 2>&1
        btrfs subvolume create "$MOUNT_POINT/@home" >> "$LOG_FILE" 2>&1
        umount "$MOUNT_POINT"

        mount -o subvol=@,compress=zstd "$ROOT_PART" "$MOUNT_POINT"
        mkdir -p "$MOUNT_POINT/home"
        mount -o subvol=@home,compress=zstd "$ROOT_PART" "$MOUNT_POINT/home"
    else
        mount "$ROOT_PART" "$MOUNT_POINT"
    fi

    log_ok "Root mounted at $MOUNT_POINT"

    # Mount EFI
    if [[ -n "${EFI_PART:-}" ]]; then
        mkdir -p "$MOUNT_POINT/boot/efi"
        mount "$EFI_PART" "$MOUNT_POINT/boot/efi"
        log_ok "EFI mounted at $MOUNT_POINT/boot/efi"
    fi
}

# =============================================================================
# Base System Installation (pacstrap)
# =============================================================================

install_base() {
    log_step "Installing base system (this may take several minutes)"

    # Enable parallel downloads for faster pacstrap
    sed -i 's/^#ParallelDownloads/ParallelDownloads/' /etc/pacman.conf

    log_info "Fetching latest pacman mirrors (this may take a moment)..."
    reflector --latest 10 --protocol https --sort rate --save /etc/pacman.d/mirrorlist 2>&1 | tee -a "$LOG_FILE"

    pacstrap -K "$MOUNT_POINT" \
        base linux linux-firmware \
        sudo systemd \
        networkmanager \
        pipewire pipewire-pulse pipewire-alsa wireplumber \
        open-vm-tools mesa \
        nano vim \
        alacritty firefox thunar \
        wayland wayland-protocols libxkbcommon libinput seatd \
        xorg-xwayland \
        sddm weston plasma-workspace \
        ttf-dejavu ttf-liberation noto-fonts \
        grub efibootmgr dosfstools os-prober amd-ucode intel-ucode \
        dbus gvfs tumbler \
        bash-completion which less man-db man-pages \
        2>&1 | tee -a "$LOG_FILE"

    log_ok "Base system installed"
}

# =============================================================================
# System Configuration (inside chroot)
# =============================================================================

configure_system() {
    log_step "Configuring installed system"

    # Generate fstab
    genfstab -U "$MOUNT_POINT" >> "$MOUNT_POINT/etc/fstab"
    log_ok "fstab generated"

    # Copy heyOS custom files into the installed system
    log_info "Deploying heyDM compositor..."

    # Copy binaries (they should exist in the live ISO's /usr/bin/)
    if [[ -f /usr/bin/heydm ]]; then
        cp /usr/bin/heydm "$MOUNT_POINT/usr/bin/heydm"
        chmod 755 "$MOUNT_POINT/usr/bin/heydm"
    fi

    # Ensure the Wayland sessions directory exists
    mkdir -p "$MOUNT_POINT/usr/share/wayland-sessions"
    cat << 'EOF' > "$MOUNT_POINT/usr/share/wayland-sessions/heydm.desktop"
[Desktop Entry]
Name=heyDM
Comment=The custom Wayland compositor for heyOS
Exec=/usr/bin/heydm
Type=Application
DesktopNames=heydm
EOF

    # Configure SDDM to use Wayland natively
    mkdir -p "$MOUNT_POINT/etc/sddm.conf.d"
    cat << 'EOF' > "$MOUNT_POINT/etc/sddm.conf.d/wayland.conf"
[General]
DisplayServer=wayland

[Wayland]
CompositorCommand=weston --shell=kiosk-shell.so
EnableHiDPI=true

[Theme]
Current=breeze
EOF

    # ---- Chroot configuration ----
    cat << 'CHROOT_SCRIPT' > "$MOUNT_POINT/tmp/hey-setup.sh"
#!/bin/bash
set -e

# Timezone
ln -sf /usr/share/zoneinfo/UTC /etc/localtime
hwclock --systohc

# Locale
echo "en_US.UTF-8 UTF-8" > /etc/locale.gen
locale-gen
echo "LANG=en_US.UTF-8" > /etc/locale.conf

# Hostname
echo "heyOS" > /etc/hostname
cat > /etc/hosts << EOF
127.0.0.1   localhost
::1         localhost
127.0.1.1   heyOS.localdomain heyOS
EOF

# Enable services
systemctl enable NetworkManager.service
systemctl enable vmtoolsd.service 2>/dev/null || true
systemctl enable seatd.service
systemctl enable sddm.service 2>/dev/null || true
systemctl set-default graphical.target

# Sudoers
echo "%wheel ALL=(ALL:ALL) ALL" > /etc/sudoers.d/00-heyos
chmod 440 /etc/sudoers.d/00-heyos

# Generate initramfs
mkinitcpio -P

echo "[heyOS] Chroot configuration complete."
CHROOT_SCRIPT

    chmod +x "$MOUNT_POINT/tmp/hey-setup.sh"
    arch-chroot "$MOUNT_POINT" /tmp/hey-setup.sh 2>&1 | tee -a "$LOG_FILE"
    rm -f "$MOUNT_POINT/tmp/hey-setup.sh"

    log_ok "System configured"
}

# =============================================================================
# Bootloader Installation
# =============================================================================

install_bootloader() {
    log_step "Installing bootloader"

    if [[ "$BOOT_MODE" == "uefi" ]]; then
        log_info "Installing GRUB for UEFI..."
        mkdir -p "$MOUNT_POINT/boot/efi"
        arch-chroot "$MOUNT_POINT" grub-install \
            --target=x86_64-efi \
            --efi-directory=/boot/efi \
            --bootloader-id=heyOS \
            --recheck 2>&1 | tee -a "$LOG_FILE"
    else
        log_info "Installing GRUB for BIOS..."
        arch-chroot "$MOUNT_POINT" grub-install \
            --target=i386-pc \
            "$TARGET_DISK" 2>&1 | tee -a "$LOG_FILE"
    fi

    # Configure GRUB
    arch-chroot "$MOUNT_POINT" bash -c '
        sed -i "s/GRUB_TIMEOUT=5/GRUB_TIMEOUT=3/" /etc/default/grub
        sed -i "s/GRUB_DISTRIBUTOR=\"Arch\"/GRUB_DISTRIBUTOR=\"heyOS\"/" /etc/default/grub
        echo "GRUB_DISABLE_OS_PROBER=false" >> /etc/default/grub
        grub-mkconfig -o /boot/grub/grub.cfg
    ' 2>&1 | tee -a "$LOG_FILE"

    log_ok "Bootloader installed and configured"
}

# =============================================================================
# User Setup
# =============================================================================

setup_user() {
    log_step "User Account Setup"

    # Set root password (loop until success)
    echo -en "${BOLD}Set root password: ${NC}\n"
    while ! arch-chroot "$MOUNT_POINT" passwd; do
        log_warn "Password setting failed. Please try again."
    done

    # Create the primary user
    echo ""
    while true; do
        echo -en "${BOLD}Enter username for the primary user: ${NC}"
        read -r NEW_USER
        if [[ -n "$NEW_USER" && "$NEW_USER" =~ ^[a-z_][a-z0-9_-]*$ ]]; then
            break
        fi
        log_err "Invalid username. Use lowercase letters, numbers, hyphens, underscores."
    done

    arch-chroot "$MOUNT_POINT" useradd -m -G wheel,video,audio,input,seat -s /bin/bash "$NEW_USER"

    echo -e "${BOLD}Set password for '$NEW_USER':${NC}"
    while ! arch-chroot "$MOUNT_POINT" passwd "$NEW_USER"; do
        log_warn "Password setting failed for '$NEW_USER'. Please try again."
    done

    log_ok "User '$NEW_USER' created with wheel, video, audio, input, seat groups"
}

# =============================================================================
# Cleanup & Finish
# =============================================================================

cleanup() {
    log_step "Finalizing installation"

    # Unmount everything
    log_info "Unmounting filesystems..."
    if mountpoint -q "$MOUNT_POINT"; then
        umount -R "$MOUNT_POINT" 2>/dev/null || true
        log_ok "Filesystems unmounted"
    fi
    
    # Remove trap so it doesn't fire again on normal exit
    trap - EXIT
}

show_complete() {
    echo -e "\n${GREEN}${BOLD}"
    cat << 'EOF'
    ╔═══════════════════════════════════════════════╗
    ║                                               ║
    ║    heyOS installation complete!               ║
    ║                                               ║
    ║    Remove the installation media and reboot   ║
    ║    to start using heyOS.                      ║
    ║                                               ║
    ║    Command: sudo reboot                       ║
    ║                                               ║
    ╚═══════════════════════════════════════════════╝
EOF
    echo -e "${NC}"
}

# =============================================================================
# Main Execution
# =============================================================================

main() {
    show_banner

    preflight_checks
    
    # Initialize log
    echo "=== heyOS Installation Log ===" > "$LOG_FILE"
    echo "Started: $(date)" >> "$LOG_FILE"
    select_disk
    select_filesystem
    partition_disk
    format_partitions
    mount_filesystems
    install_base
    configure_system
    install_bootloader
    setup_user
    cleanup
    show_complete

    echo "Completed: $(date)" >> "$LOG_FILE"
}

# Run the installer
main "$@"
